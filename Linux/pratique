// 

// Infos du host (version/distribution d' OS):
centos -----> sudo hostnamectl   
ubuntu -----> sudo cat /etc/lsb-release

// Emplacement java
update-java-alternatives -l

// Pour vérifier si Systemd est installé, on tape :   ps -p 1

// Checker les logs pour un service : ----> journalctl --help
sudo journalctl --unit elasticsearch (log pour elasticsearch)

// Liste de packages installés ubuntu pour les supprimer...
$ dpkg --list

// Etat su système ---> taper w dans l'invite de commandes
// La durée de fonctionnement de l'ordinateur -----> $ uptime  ---> plus d'infos 

// Commandes utiles VIM
- copier une ligne : echap+v + curseur au début de ligne + Y   
- coller une ligne : p ou P
- copier 5 ligne à partir du curseur ----> 5yy  et coller p
- supprimer une ligne : echap + dd    ,   `echap + cc` supprime le contenu de la ligne
- supprimer 5 lignes à partir du curseur --->5dd
- annuler une modification : echap + u  (undo)  et ctrl+r (redo)
- rechercher un mot ----> /mot + entrée , l'occurence suivant n

// Trouver un fichier avec find (find cherche dans le disque) 
find -name "syslog*"
find /var/log/ -name "syslog*"   ----> cherche à /var/log/
find /var/log/ -name "syslog*" -type f  ----->  type est un fichier (d pour dossier)
find  ~ -size +1G    ----->  tous le fichiers de plus de 1Go


// Commenter des lignes VIM:
 Pour commenter les lignes 15 à 30 ---------------->  ESC + :15,30s/^/#   et pour décomenter  :15,30s/^#
 Pour commenter les 23 lignes suivantes (par rapport au curseur) :ESC + :.,+23s/^/#  

// Comande tail
......

// Gestion des logs
find  /var/log  -size +1M    ---> les logs qui ont +1Mo
find -name "*.txt" -atime 1  ---> nombre de jours qui vous séparent du dernier accès à un fichier *.txt

// Commande sed
  sed -i 's/mot_original/nouveau_mot/g' nom_fichier.txt  ----> (s = substitution, g = tous les mots de la ligne)
  
// Commande tee : la sortie de la 1ère commade est stockée dans un fichier.Avec l'option -a , tee n'écrasera pas l'ancien fichier.
echo "deb http://packages.elastic.co/kibana/4.6/debian stable main" | sudo tee -a /etc/apt/sources.list.d/kibana.list

// Commande grep
grep -i ---> rend la recherche insensible à la casse
grep -r ---> effectue une recherche récursive

// Quelques commandes Filesystem
/etc/fstab ---> la table des systèmes de fichiers montés à chaque démarrage de Linux
/etc/mtab ---> la table des systèmes de fichiers qui sont montés
/etc/passwd ---> le fichier de configuration des comptes utilisateurs
/etc/group ---> le fichier de configuration des groupes
/etc/shadow ---> le fichier de configuration des mots de passe

// Lister les process
   // Lister all processes --->  ps -ax or -e
   // lister  by user ------> ps -u
sudo ps aux | grep java    ---->  ps java est-il  run?
sudo ps a
// Lister les ports
sudo netstat -tulpn | grep LISTEN
sudo netstat -tulpn | grep 80     // le process qui écoute sur le port 80

// Tuer le process qui utilise le port 80
sudo kill $(sudo lsof -t -i :80)

// Lister les process qui écoutent sur le port 8080 avec lsof
sudo lsof -n -i:8080 | grep LISTEN | awk '{ print $2 }'

// systemctl <action> <nom_du_service>      ----->   systemctl start docker

// Si on ne veut pas ni voir le résultat d'une commande ni le stocker dans un fichier. L'astuce consiste à rediriger le résultat dans /dev/null. 
C'est un peu le « trou noir » de Linux : tout ce qui va là-dedans disparaît immédiatement.

// Lister les users
sudo less /etc/passwd   -----> affiche une liste à 7 colonnes
sudo cut -d: -f1 /etc/passwd    -----> selectionner la 1ère colonnee user)
sudo awk -F: '{ print $1 }' /etc/passwd  -----> pareil : selectionner la 1ère colonne (nom de user)
avec un getent et grep , on trouve le nom du user : getent passwd  | grep amlas | awk -F: '{ print $1 }'
- nombre de user: sudo getent passwd | wc -l

// Créer un lien symbolique
$ ln  -s  /nom_du_dossier_source  nom_du_lien    (répertoire courant)
$ ln  -s  /emplacement/nom_du_fichier_source  nom_du_lien
$ ln -s   /emplacement/nom_du_fichier_source /emplacement/nom_du_lien (chemin absolu)

// Les flux de redirection
2> : redirige les erreurs dans un fichier (s'il existe déjà, il sera écrasé) ;
2>> : redirige les erreurs à la fin d'un fichier (s'il n'existe pas, il sera créé) ;
2>&1 : redirige les erreurs au même endroit et de la même façon que la sortie standard.
.???....   >> /dev/null
