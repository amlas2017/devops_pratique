
// L'IP de la machine  ------> hostname -I

// cut -d: -f6 /etc/passwd   ----> affiche le 6eme champ du fichier /etc/passwd, dont le séparateur de champs est ":".

// Infos du host (version/distribution d' OS):
centos -----> sudo hostnamectl   
ubuntu -----> sudo cat /etc/lsb-release

// Emplacement java
update-java-alternatives -l

// Pour vérifier si Systemd est installé, on tape :   ps -p 1

// Synchronisation avec rsync:
rsync  -vr ./dossier1/ ./dossier2

// Modifier le compte d'un user avec usermod
usermod modifie les fichiers d'administration des comptes du système selon les modifications qui ont été indiquées sur la ligne
de commande : sudo usermod -g groupe-existant user-existant

//**************************************************** SUID  *******************************************************************
Il permet de faire en sorte de lancer un programme en tant que l'user qui possède le fichier et non en tant que celui qui lance
le fichier.  ---->  chmod 4755 nom_du_fichier   ,  setuid=4
             ---->  chmod 6755 nom_du_fichier   , 6 = setuid(4) + setgid(2)

// Checker les logs pour un service : ----> journalctl --help
sudo journalctl --unit elasticsearch (log pour elasticsearch)

// Liste de packages installés ubuntu pour les supprimer...
$ dpkg --list

// Si une commande par erreur a été lancée en AVANT-PLAN et qu'on veut récupérer l'invite de commandes,il faudra faire dans l'ordre:
Ctrl + Z : pour mettre en pause le programme et récupérer l'invite de commandes ;
bg : pour que le processus continue à tourner mais en arrière-plan.
La commande fg renvoie un processus au premier plan (la commande jobs liste les processus qui tournent en arrière-plan).

// Etat su système ---> taper w dans l'invite de commandes
// La durée de fonctionnement de l'ordinateur -----> $ uptime  ---> plus d'infos 

// Execution de commandes en arrière plan avec &  -----> $ find / -name "*log" > sortie_find.txt 2>&1 & (les erreurs vers sortie &1)
// Avec l'option & ,le processus reste attaché à la console: si la console est fermée ou que l'user se déconnecte, le processus
// sera automatiquement arrêté.Si on veut que le processus continue, il faut lancer la commande nohup :
 $ nohup find / -name "*log"    ----> La sortie de la commande est par défaut redirigée vers un fichier nohup.out.
 
###################################################################################################################################
                                                     Commandes utiles VIM   ----> vimtutor fr
###################################################################################################################################
- copier une ligne : echap+v + curseur au début de ligne + Y  et  y+w pour copier un mot
- coller une ligne : p ou P
- copier 5 ligne à partir du curseur ----> 5yy  et coller p
- supprimer une ligne : echap + dd    ,   `echap + cc` supprime le contenu de la ligne
- supprimer 5 lignes à partir du curseur ---> 5dd
- Pour effacer jusqu'à la fin de la ligne courante : d$
- annuler une modification : echap + u  (undo)  et ctrl+r (redo)
- rechercher un mot ----> /mot + entrée , l'occurence suivant n
- Chercher et remplacer --->  :%s/mot-cherché/nouveau-mot/g
###################################################################################################################################
                                                        Commande FIND
###################################################################################################################################

// Trouver un fichier avec find (find cherche dans le disque) 
find -name "syslog*"
find /var/log/ -name "syslog*"   ----> cherche à /var/log/
find /var/log/ -name "syslog*" -type f  ----->  type est un fichier (d pour dossier)
find  ~ -size +1G    ----->  tous le fichiers de plus de 1Go


// Commenter des lignes VIM:
 Pour commenter les lignes 15 à 30 ---------------->  ESC + :15,30s/^/#   et pour décomenter  :15,30s/^#
 Pour commenter les 23 lignes suivantes (par rapport au curseur) :ESC + :.,+23s/^/#  

// Comande tail
tail -f /var/log/access.log    ---->  affiche en mode debug ( après chaque execution) 
......

// Gestion des logs
find  /var/log  -size +1M    ---> les logs qui ont +1Mo
find -name "*.txt" -atime 1  ---> nombre de jours qui vous séparent du dernier accès à un fichier *.txt

// Commande sed
  sed -i 's/mot_original/nouveau_mot/g' nom_fichier.txt  ----> (s = substitution, g = tous les mots de la ligne)
  
// Commande tee : la sortie de la 1ère commade est stockée dans un fichier.Avec l'option -a , tee n'écrasera pas l'ancien fichier.
echo "deb http://packages.elastic.co/kibana/4.6/debian stable main" | sudo tee -a /etc/apt/sources.list.d/kibana.list

// Commande grep
grep -i ---> rend la recherche insensible à la casse
grep -r ---> effectue une recherche récursive

// Quelques commandes Filesystem
/etc/fstab ---> la table des systèmes de fichiers montés à chaque démarrage de Linux
/etc/mtab ---> la table des systèmes de fichiers qui sont montés
/etc/passwd ---> le fichier de configuration des comptes utilisateurs
/etc/group ---> le fichier de configuration des groupes
/etc/shadow ---> le fichier de configuration des mots de passe

// Lister les process (statique)
   // Lister all processes --->  ps -ax or -e
   // lister  by user ------> ps -u
sudo ps aux | grep java    ---->  ps java est-il  run?
sudo ps a
pstree   --------> arbre des processus

// Processus lancés par un user ----> ps -u utilisateur
// Liste dynamique des processus   ---> top  ou   htop

// Lister les ports
sudo netstat -tulpn | grep LISTEN
sudo netstat -tulpn | grep 80     // le process qui écoute sur le port 80

###################################################################################################################################
                                                Commandes utiles lsof
###################################################################################################################################
// La commande lsof
lsof -i  ----->   tous services internet TCP/UDP
lsof -i tcp  ---->  tous services TCP
lsof -i udp  ---->   tous services UDP
lsof -i tcp:80    ----->  services TCP sur port 80
lsof -u toto   ---->  fichiers ouverts par l'utilisateur "toto"
lsof +D /tmp      ------->   savoir qui utilise les fichiers d'un répertoire
Les PID des process qui écoutent sur le port 8080 avec lsof  ------->  sudo lsof -n -i:8080 | grep LISTEN | awk '{ print $2 }'
Tuer le process qui utilise le port 80    ------>  sudo kill $(sudo lsof -t -i :80)
                                    ou    ------> sudo lsof -i :80 | awk 'NR>1 { print $2 } | xargs sudo kill  

// systemctl <action> <nom_du_service>      ----->   systemctl start docker

// Si on ne veut pas ni voir le résultat d'une commande ni le stocker dans un fichier. L'astuce consiste à rediriger le résultat dans /dev/null. 
C'est un peu le « trou noir » de Linux : tout ce qui va là-dedans disparaît immédiatement.

// Lister les users
sudo less /etc/passwd   -----> affiche une liste à 7 colonnes
sudo cut -d: -f1 /etc/passwd    -----> selectionner la 1ère colonnee user , délimiteur est ":"
sudo awk -F: '{ print $1 }' /etc/passwd  -----> pareil : selectionner la 1ère colonne (nom de user)
avec un getent et grep , on trouve le nom du user : getent passwd  | grep amlas | awk -F: '{ print $1 }'
- nombre de user: sudo getent passwd | wc -l

// Créer un lien symbolique
$ ln  -s  /nom_du_dossier_source  nom_du_lien    (répertoire courant)
$ ln  -s  /emplacement/nom_du_fichier_source  nom_du_lien
$ ln -s   /emplacement/nom_du_fichier_source /emplacement/nom_du_lien (chemin absolu)

// Les flux de redirection
2> : redirige les erreurs dans un fichier (s'il existe déjà, il sera écrasé) ;
2>> : redirige les erreurs à la fin d'un fichier (s'il n'existe pas, il sera créé) ;
2>&1 : redirige les erreurs au même endroit et de la même façon que la sortie standard.
.???....   >> /dev/null

// verbose = affiche ce qu'il fait

// Les commandes entre les `commande1 commande2` permettent d'insérer le résultat d'une commande dans une autre commande. 

****************************************************** RSYSLOG ****************************************************************
Rsyslog est un logiciel libre utilisé sur des systèmes d'exploitation de type Unix (Unix, Linux) transférant les messages des 
journaux d'événements sur un réseau IP. Rsyslog implémente le protocole basique syslog - qui centralise les journaux d'événements,
permettant de repérer plus rapidement et efficacement les défaillances d'ordinateurs présents sur un réseau. Il présente la 
particularité d'en étendre les fonctionnalités en permettant, notamment, de filtrer sur des champs, de filtrer à l'aide 
d'expressions régulières et l'utilisation du protocole TCP de la couche transport.

Les fonctionnalités principales :
* il remplace facilement syslog (les règles de syslog peuvent être simplement copiées dans /etc/rsyslog) 2
* il peut écrire les événements dans une base de données (MySQL ou postgreSQL)
* il gère la rotation automatique des fichiers
* il peut mettre en tampon (sous forme de fichiers) des événements
* il gère GSS-API et TLS 2
* il peut être utilisé comme un relais et peut être configuré pour enregistrer les points de passage
* il peut utiliser son propre protocole réseau : RELP (Reliable Event Logging Protocol) qui offre une meilleure garantie de 
  réception des événements par le serveur.
* il peut utiliser un format de date complet (incluant l'année, contrairement au syslog de base qui n'inclut jamais l'année) et
  pouvant être précis jusqu'au millième de seconde (contrairement à syslog qui n'est précis qu'à la seconde).

Rsyslog implémente syslog. Ainsi les outils utilisés pour syslog restent valable. En particulier l'utilitaire logger.
     $ logger System rebooted
     # tail -f /var/log/syslog


